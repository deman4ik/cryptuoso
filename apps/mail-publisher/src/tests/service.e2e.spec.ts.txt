process.env.MAILGUN_DOMAIN = "abc.com";

const DEFAULT_FROM = `Cryptuoso <noreply@${process.env.MAILGUN_DOMAIN}>`;

import Service from "../app/service";
import { buildEmail } from "../app/utils";
import {
    MailPublisherEvents,
    MailPublisherEventData,
    TemplateMailType,
    TemplateMailData
} from "@cryptuoso/mail-publisher-events";
import { sleep } from "@cryptuoso/helpers";
import { v4 as uuid } from "uuid";
import { COVER_TEMPLATE_TYPES } from "@cryptuoso/mail";

var mockMailGun = {
    send: jest.fn(),
    subscribeToList: jest.fn(),
    lists: mockMailGunLists
};

var mockMailGunLists = jest.fn(() => ({
    members: () => ({
        create: mockMailGun.subscribeToList
    })
}));

mockMailGun.lists = mockMailGunLists;

jest.mock(
    "mailgun-js",
    () =>
        function () {
            return {
                messages: () => ({
                    send: mockMailGun.send
                }),
                lists: mockMailGunLists
            };
        }
);

describe("", () => {
    const service = new Service();
    const events = service.events;

    beforeAll(async (done) => {
        await service.startService();

        done();
    });

    describe("Send mail event", () => {
        describe("Test default fields filling", () => {
            test("Provided object should be right", async () => {
                const sendProps = {
                    to: uuid(),
                    subject: uuid(),
                    text: uuid(),
                    html: uuid(),
                    tags: [uuid()]
                };
                mockMailGun.send.mockClear();

                await events.emit<MailPublisherEventData[MailPublisherEvents.SEND_MAIL]>({
                    type: MailPublisherEvents.SEND_MAIL,
                    data: sendProps
                });

                await sleep(3000);

                /* console.warn(mockMailGun.send.mock.calls[0]);
    
                await sleep(1000); */

                expect(mockMailGun.send).toBeCalledWith({
                    from: DEFAULT_FROM,
                    to: sendProps.to,
                    subject: sendProps.subject,
                    text: sendProps.text,
                    html: sendProps.html,
                    template: "simple",
                    "h:X-Mailgun-Variables": undefined,
                    "o:tag": sendProps.tags
                });
            });
        });

        describe("Test with other fields", () => {
            test("Provided object should be right", async () => {
                const sendProps = {
                    from: uuid(),
                    to: uuid(),
                    subject: uuid(),
                    text: uuid(),
                    html: uuid(),
                    variables: {
                        body: uuid()
                    },
                    tags: [uuid()],
                    template: COVER_TEMPLATE_TYPES.main
                };
                mockMailGun.send.mockClear();

                await events.emit<MailPublisherEventData[MailPublisherEvents.SEND_MAIL]>({
                    type: MailPublisherEvents.SEND_MAIL,
                    data: sendProps
                });

                await sleep(3000);

                expect(mockMailGun.send).toBeCalledWith({
                    from: sendProps.from,
                    to: sendProps.to,
                    subject: sendProps.subject,
                    text: sendProps.text,
                    html: sendProps.html,
                    template: sendProps.template,
                    "h:X-Mailgun-Variables": JSON.stringify(sendProps.variables),
                    "o:tag": sendProps.tags
                });
            });
        });
    });

    describe("Subscribe to list event", () => {
        test("", async () => {
            const subsProps = {
                email: uuid(),
                list: uuid(),
                name: uuid()
            };

            mockMailGun.subscribeToList.mockClear();

            await events.emit<MailPublisherEventData[MailPublisherEvents.SUBSCRIBE_TO_LIST]>({
                type: MailPublisherEvents.SUBSCRIBE_TO_LIST,
                data: subsProps
            });

            await sleep(3000);

            expect(mockMailGun.lists).toBeCalledWith(subsProps.list);

            expect(mockMailGun.subscribeToList).toBeCalledWith({
                subscribed: true,
                address: subsProps.email,
                name: subsProps.name
            });
        });
    });

    describe("Send notification", () => {
        test("", async () => {
            const type = TemplateMailType.WELCOME;
            const data: TemplateMailData[TemplateMailType.WELCOME] = {
                secretCode: uuid(),
                urlData: uuid()
            };
            const db = service.db;

            const user: { id: string; email: string } = await db.pg.one(db.sql`
                SELECT id, email
                FROM users
                WHERE email IS NOT NULL
                LIMIT 1;
            `);

            mockMailGun.send.mockClear();

            await service.mailUtilInstance.send({
                ...buildEmail(type, data),
                to: user.email
            });

            const refObj = mockMailGun.send.mock.calls[0][0];

            //console.warn(refObj);

            mockMailGun.send.mockClear();

            const notificationId = (await db.pg.oneFirst(db.sql`
                INSERT INTO notifications(
                    type, data, user_id, send_email
                ) VALUES (
                    ${type},
                    ${db.sql.json(data)},
                    ${user.id},
                    true 
                )
                RETURNING id;
            `)) as string;

            //console.warn(notificationId);

            await events.emit<MailPublisherEventData[MailPublisherEvents.SEND_NOTIFICATION]>({
                type: MailPublisherEvents.SEND_NOTIFICATION,
                data: {
                    notificationId
                }
            });

            await sleep(3000);

            //console.warn(mockMailGun.send.mock.calls[0][0]);

            expect(mockMailGun.send).toBeCalledWith(refObj);

            await db.pg.query(db.sql`
                DELETE
                FROM notifications
                WHERE id = ${notificationId};
            `);
        });
    });

    describe("Send template mail", () => {
        test("", async () => {
            const to = uuid();
            const type = TemplateMailType.CHANGE_EMAIL_CONFIRMATION;
            const data: TemplateMailData[TemplateMailType.CHANGE_EMAIL_CONFIRMATION] = {
                emailNew: uuid()
            };

            mockMailGun.send.mockClear();

            await service.mailUtilInstance.send({
                ...buildEmail(type, data),
                to
            });

            const refObj = mockMailGun.send.mock.calls[0][0];

            //console.warn(refObj);

            mockMailGun.send.mockClear();

            await events.emit<MailPublisherEventData[MailPublisherEvents.SEND_TEMPLATE_MAIL]>({
                type: MailPublisherEvents.SEND_TEMPLATE_MAIL,
                data: {
                    type,
                    to,
                    data
                }
            });

            await sleep(3000);

            //console.warn(mockMailGun.send.mock.calls[0][0]);

            expect(mockMailGun.send).toBeCalledWith(refObj);
        });
    });
});
