import Service from "../app/service";
import { MailPublisherEvents, TemplateMailType, mailPublisherConfig } from "@cryptuoso/mail-publisher-events";
import { Signal, SignalEvents } from "@cryptuoso/robot-events";
import { v4 as uuid } from "uuid";
import dayjs from "@cryptuoso/dayjs";
import { OrderType, SignalType, TradeAction } from "@cryptuoso/market";
import { sleep } from "@cryptuoso/helpers";
import { Events } from "@cryptuoso/events";

jest.setTimeout(25000);

describe("", () => {
    const service = new Service();

    beforeAll(async (done) => {
        await service.startService();

        done();
    });

    function testSimpleSignal(
        argSignal:
            | {
                  type: SignalType.alert;
                  action: TradeAction;
              }
            | {
                  type: SignalType.trade;
                  action: TradeAction.long | TradeAction.short;
              }
    ) {
        describe("", () => {
            test("", async () => {
                const info: {
                    userId: string;
                    robotId: string;
                    robotCode: string;
                    positionId: string;
                    positionCode: string;
                    positionPrefix: string;
                } = await service.db.pg.maybeOne(service.db.sql`
                    SELECT u.id as user_id,
                        r.id as robot_id,
                        r.code as robot_code,
                        rp.id as position_id,
                        rp.code as position_code,
                        rp.prefix as position_prefix
                    FROM users u, user_signals us, robots r, robot_positions rp
                    WHERE us.user_id = u.id
                        AND r.id = us.robot_id
                        AND rp.robot_id = r.id
                        AND rp.status = 'closed'
                        AND u.email IS NOT NULL
                        AND u.settings->'notifications'->'signals'->'email'::text = 'true'
                    LIMIT 1;
                `);

                const signal: Signal = {
                    id: uuid(),
                    type: argSignal.type,
                    action: argSignal.action,
                    orderType: OrderType.market,
                    timeframe: 5,
                    timestamp: dayjs.utc().toISOString(),
                    candleTimestamp: dayjs.utc().toISOString(),
                    exchange: uuid(),
                    asset: uuid(),
                    currency: uuid(),
                    positionId: info.positionId,
                    positionCode: info.positionCode,
                    positionPrefix: info.positionPrefix,
                    robotId: info.robotId,
                    price: 123
                };

                const notificationIds: string[] = [];

                const events = new Events(service.redis, service.lightship);

                events.subscribe({
                    [MailPublisherEvents.SEND_NOTIFICATION]: {
                        handler: async (data: { notificationId: string }) => {
                            console.warn(data);
                            notificationIds.push(data.notificationId);
                        }
                    }
                });

                events.start();

                const templateType =
                    argSignal.type === SignalType.alert ? TemplateMailType.SIGNAL_ALERT : TemplateMailType.SIGNAL_TRADE;

                (mailPublisherConfig as any).tagByType.set(templateType, "123");

                await service.events.emit<Signal>({
                    type: argSignal.type === SignalType.alert ? SignalEvents.ALERT : SignalEvents.TRADE,
                    data: signal
                });

                await sleep(3000);

                expect(notificationIds.length).toBeGreaterThan(0);

                const notifications = await service.db.pg.any(service.db.sql`
                    DELETE
                    FROM notifications
                    WHERE id = ANY(${service.db.sql.array(notificationIds, service.db.sql`uuid[]`)})
                    RETURNING "type", "data";
                `);

                (mailPublisherConfig as any).tagByType.delete(templateType);

                let has = false;
                const comparingObject = {
                    type: templateType,
                    data: { ...signal, robotCode: info.robotCode }
                };

                notifications.forEach((n) => {
                    try {
                        expect(n).toEqual(comparingObject);
                        has = true;
                    } catch (err) {}
                });

                expect(has).toBeTruthy();
            });
        });
    }

    function testComplexSignal(action: TradeAction.closeShort | TradeAction.closeLong) {
        describe("", () => {
            test("", async () => {
                const info: {
                    userId: string;
                    robotId: string;
                    robotCode: string;
                    positionId: string;
                    positionCode: string;
                    positionPrefix: string;
                } = await service.db.pg.maybeOne(service.db.sql`
                    SELECT u.id as user_id,
                        us.id AS signal_id, 
                        r.id as robot_id,
                        r.code as robot_code,
                        rp.id as position_id,
                        rp.code as position_code,
                        rp.prefix as position_prefix
                    FROM users u, user_signals us, robots r, robot_positions rp
                    WHERE us.user_id = u.id
                        AND r.id = us.robot_id
                        AND rp.robot_id = r.id
                        AND rp.status = 'closed'
                        AND u.email IS NOT NULL
                        AND u.settings->'notifications'->'signals'->'email'::text = 'true'
                    LIMIT 1;
                `);

                const signal: Signal = {
                    id: uuid(),
                    type: SignalType.trade,
                    action: action,
                    orderType: OrderType.market,
                    timeframe: 5,
                    timestamp: dayjs.utc().toISOString(),
                    candleTimestamp: dayjs.utc().toISOString(),
                    exchange: uuid(),
                    asset: uuid(),
                    currency: uuid(),
                    positionId: info.positionId,
                    positionCode: info.positionCode,
                    positionPrefix: info.positionPrefix,
                    robotId: info.robotId,
                    price: 123
                };

                const notificationIds: string[] = [];

                const events = new Events(service.redis, service.lightship);

                events.subscribe({
                    [MailPublisherEvents.SEND_NOTIFICATION]: {
                        handler: async (data: { notificationId: string }) => {
                            console.warn(data);
                            notificationIds.push(data.notificationId);
                        }
                    }
                });

                events.start();

                (mailPublisherConfig as any).tagByType.set(TemplateMailType.SIGNAL_TRADE, "123");

                await service.events.emit<Signal>({
                    type: SignalEvents.TRADE,
                    data: signal
                });

                await sleep(3000);

                expect(notificationIds.length).toBeGreaterThan(0);

                const notifications = await service.db.pg.any<any>(service.db.sql`
                    DELETE
                    FROM notifications
                    WHERE id = ANY(${service.db.sql.array(notificationIds, service.db.sql`uuid[]`)})
                    RETURNING "type", "data";
                `);

                (mailPublisherConfig as any).tagByType.delete(TemplateMailType.SIGNAL_TRADE);

                const usersSignalPositions: {
                    userId: string;
                    volume: number;
                    profit: number;
                    entryAction: TradeAction;
                    entryPrice: number;
                    entryDate: string;
                    barsHeld: number;
                } = await service.db.pg.maybeOne(service.db.sql`
                    SELECT volume, profit, entry_action, entry_price, entry_date, bars_held
                    FROM v_user_signal_positions
                    WHERE id = ${signal.positionId}
                        AND robot_id = ${signal.robotId}
                        AND user_id = ${info.userId};
                `);

                let has = false;
                const comparingObject = {
                    type: TemplateMailType.SIGNAL_TRADE,
                    data: { ...signal, robotCode: info.robotCode, ...usersSignalPositions }
                };

                notifications.forEach((n) => {
                    try {
                        expect(n).toEqual(comparingObject);
                        has = true;
                    } catch (err) {
                    }
                });

                expect(has).toBeTruthy();
            });
        });
    }

    /* testSimpleSignal({
        type: SignalType.alert,
        action: TradeAction.short
    }); */
    
    /* testSimpleSignal({
        type: SignalType.trade,
        action: TradeAction.short
    }); */

    /* testSimpleSignal({
        type: SignalType.trade,
        action: TradeAction.long
    }); */

    //testComplexSignal(TradeAction.closeLong);

    testComplexSignal(TradeAction.closeShort);
});
